---
layout:     post
title:      内核同步
subtitle:   
date:       2021-02-25
author:     BY beta
header-img: img/2021-02-25/head.png
catalog:    true
tags:

    - 内核同步
    - 操作系统
---

## 前言

为什么需要内核同步

- 共享数据
- 临界区域（critical regions）：一个访问共享资源（例如：共享设备或是共享存储器）的程序片段，而这些共享资源又无法同时被多个[线程](https://zh.wikipedia.org/wiki/執行緒)访问的特性
- 竞争状态：当两个线程同时访问临界区域
- 同步：防止不安全的并发，避免竞争状态

举例如下，两个线程同时操作i

![image-20210225205133951](https://i.loli.net/2021/02/25/2gxZMlGrSXUmnVq.png)

## 1. 原子指令

操作 之前，加一个lock的变量，这样每次只能有一个进程能取得lock的值。但是中断和抢占会破坏原子性。

![image-20210225205938467](https://i.loli.net/2021/02/25/sMB86lycx9NiDg4.png)

lock需要注意的情况

- 数据是否全局
- 进程在访问数据的时候，是否会被抢占
- 如果多个线程、多个资源。其加锁和解锁的顺序

## 2.同步的原因

同步有两种表现：

- 伪同步：两个线程并未同时执行临界区域，交错执行
- 真同步

![image-20210225210326723](C:/Program Files/Typora/upload/image-20210225210326723.png)

同步产生的原因：

- 中断
- softirqs
- 内核抢占
- 用户空间的同步和sleeping
- 多处理器

中断安全：中断处理程序中能避免并发访问的代码

SMP安全：对称多处理的机器中能避免并发访问的代码

抢占安全：在内核抢占时能避免并发访问的安全代码

## 3. spin lock 

自旋锁：如果在获取自旋锁时，没有任何执行单元保持该锁，那么将立即得到锁；如果在获取自旋锁时锁已经有保持者，那么获取锁操作将自旋在那里，直到该自旋锁的保持者释放了锁

## 4. semaphores 和 mutex

信号量、互斥体和自旋锁都是内核同步的方法