## segment fault，core dump

段错误，核心已转储。

### 1. 错误原因

基本上原因是非法访问内存，具体的有：

1. 内存访问越界

   - 使用错误的下标，导致数组的访问越界

   - 搜索字符串时，依靠字符串结束符来判断字符串是否结束，但是字符串没有正常的使用结束符

   - 使用strcpy，strcat，strcmp等字符串操作函数。应该使用strncpy，strlcpy等函数防止读写过界。

     

2. 非法指针

   - 使用空指针
   - 随意使用指针转换。一个指向一段内存的指针，除非确定这段内存原先就分配为某种结构或类型，或者这种结构或类型的数组，否则不要将它转换为这种结构或类型 的指针，而应该将这段内存拷贝到一个这种结构或类型中，再访问这个结构或类型。这是因为如果这段内存的开始地址不是按照这种结构或类型对齐的，那么访问它 时就很容易因为bus error而core dump.

3. 堆栈溢。大的局部变量（局部变量都分配至栈上），容易造成堆栈溢出，破坏系统的栈和堆结构，导致莫名其妙的错误。

4. 多线程程序使用了线程不安全的函数

5. 多线程读写的数据未加锁保护。对于会被多个线程同时访问的全局数据，应该注意加锁保护，否则很容易造成core dump。



### 2.定位错误

调试段错误，一般依赖core文件和gdb来定位错误。

1. 确保中断信号能够产生coredump

2. 系统允许core文件生成

   `ulimit -a` 查看core file大小，如果为0，表示系统关闭了dump core；

   `ulimit -c unlimited` 打开dump core， 但只对当前进程有效。在~/.bashrc 文件中写入：`ulimit -c unlimited`，一直有效

3. 编译程序时，加入-g 选项



### 参考文章

https://blog.csdn.net/l460133921/article/details/71908364