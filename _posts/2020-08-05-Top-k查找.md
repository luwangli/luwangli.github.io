```
layout:		post
title:		Top-k频繁项
subtile:	如何在数据流中查找Top-k频繁项
date:		2020-08-05
author:		By beta
header-img:
catalog:	true
tags:
	-		算法
	-		科研
	-		编程

```

## 前言

寻找数据流中出现最频繁的k个元素，这个问题和自己目前的研究兴趣有很大的相关性，只不过在具体的场景中可能有其他的限制条件，但抽象的问题并没有实质的区别。

## 1.Hashmap + 最小堆

这是最直观的想法，使用hashmap存储所有的`<string,int>`存放所有元素出现的次数；用容量为k的min-heap存放目前出现过的最频繁的k个元素。

具体插入流程：

1. 每次从数据流中提取数据，如果在Hashmap中存在，则把相应的计数器加1；如果不存在，则将该元素插入到hashmap中，初始为1；

2. 在min-heap中遍历查找该元素，

   2.1 如果找到，则把堆里的计数器加1，并向下调整堆；

   2.2 如果没找到，并且堆未满，则在堆尾插入该元素，向上调整，

   2.3 如果没找到，并且堆已满，则将该元素的次数与堆顶比较，若大于堆顶元素的次数，则将堆顶替换为该元素，并向下调整

## 2.frequent algorithm

首次由Misra和Gries提出，思路很简单，保存k个`<item,count>`组成的条目，核心的想法是，每次到达的元素若在条目中，则元素对应的条目计数加一，否则所有的条目计数减一。因为如果一个元素的频率大于`N/K`, 那么每次减少都可以被抵消。伪代码如下：

```
输入：N为数据流项集合，T为存储条目集合
T <- Φ
for each i in N:
	if i ∈ T
		count[i] <- count[i]+1;
	else if |T|<k
		T <- T ∪ {i};
		count[i] <- 1;
	else
		all counter decrease 1;
		if count[j] ==0 T <- T\{j}
```

可以很明显的看出，对于top-k寻找而言，若该元素的频率大于N/k，则一定会被找出，但是频数估计会存在较大误差；并且top-k不一定能保证前k项都大于N/k，所以也会出现精度的误差

## 3.space saving







