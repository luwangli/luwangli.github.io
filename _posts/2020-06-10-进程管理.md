## 进程管理

进程A调动进程B的过程：

进程A->内核提供的系统调用

进程如何产生操作系统的调用



整体过程：

![image-20200610192753966](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200610192753966.png)

### 1.1 进程在系统中的布局

当只有进程A时，操作系统内存布局如下：

![image-20200610194724122](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200610194724122.png)

###　1.2进程Ａ调用操作系统

进程通过软中断soft interrupt，比如int80

![image-20200610195451739](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200610195451739.png)

glibc中的fork函数为了调用kernel，需要先修改寄存器，然后使用中断

![image-20200610195939128](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200610195939128.png)

### 异常和中断处理

同步异常，因为异常都是由于CPU处理到异常的指令造成的，与CPU同步。操作系统启动的时候，会将异常向量表（vector table）加载到内存中，如果操作系统遇到不会处理的指令，回去向量表中查找。

![image-20200610200320638](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200610200320638.png)

异常为synchronous exception，中断为asynchronous exception，下图可以看到，除了初始的阶段不同，后期两者对于cpu内部的操作是一样，不过是中断需要外部的“刺激”



![image-20200613214415806](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200613214415806.png)





举例而言：上一节中的glib库的fork函数，通过int 0x80引起中断，80表示这个中断是系统调用，接着内核使用syscall handler 来捕捉，并在syscall table找到第二个（eax寄存器指定）操作，sys_fork()函数

![image-20200610202125020](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200610202125020.png)

![image-20200610202749569](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200610202749569.png)

操作系统不是一个会执行的程序，进程A进入到内核态时，上下文【context】不会变化

![image-20200610203753492](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200610203753492.png)

### 程序和进程的区别

程序是静态的文件，通常格式为ELF（可执行文件，executable file），保存在磁盘；进程存在在内存中，并已经执行。

> 程序是一组指令的有序集合，是静态的实体。而进程是程序在某个数据集的执行。进程和程序并非一一对应的关系，一个程序执行在不同的数据集就成为不同的进程。

进程 =  程序 + 数据

![image-20200610204513973](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200610204513973.png)

### 1.3 fork过程

每个进程在kernel中都会存储一个结构保存重要信息，如PID等。进程A fork进程B的过程中，会直接复制进程A的结构，然后修改这个结构，比如PID。如下图，

![image-20200610210720634](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200610210720634.png)

进程描述符【结构】如下图所示，在linux中的形式

![image-20200610211001999](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200610211001999.png)

进程的状态变化图

![image-20200610211938233](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200610211938233.png)

### 1.4 进程调度

#### 中断

寻找下一个运行的进程。进程调度的场景：

- 当前进程需要其他工作。进程自身调用kernel的函数，如sysytem call。

- 当前进程占据太多时间。内核在进程运行时会设置一个时间，时间用完会调用kernel。如下，进程调度有可能会导致进程切换，也有可能回到原进程。

  ![image-20200613214848413](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200613214848413.png)

- 更重要的进程出现。如鼠标、键盘等操作。

  ![image-20200613212709297](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200613212709297.png)



分段

**用户进程可以被打断，那么kernel能否被打断呢**



![image-20200614095730819](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200614095730819.png)







#### 抢占

用户抢占(user preemption)和内核抢占（kernel preemption），注意抢占不等于中断

非抢占式内核支持用户抢占（eg. linux kernel 2.4)

抢占式内核支持用户抢占和内核抢占(eg. linux kernel 2.6)

![image-20200614100828400](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200614100828400.png)

#### 调度算法

考虑的因素,进程优先级,等待时间等等。





###　1.5 context 切换

存储当前进程的状态

![image-20200614105626821](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200614105626821.png)

e.g  进程A切换到进程B的过程（CPU存储了当前进程的基本状态，如IP指向下一个指令，SP指向栈等等）。

- 进程A由于某些原因进入内核进程调度模块
- 进程调度决定将进程A切换到进程B

- kernel将进程A的状态，即当前cpu的某些寄存器，存储到kernel space中，linux kernel将这些进程状态的信息所在文件命名为TSS（task state segment）
- 将进程B的TSS文件读取，并存入CPU
- 读取CPU，就开始运行进程B啦

![image-20200614105912746](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200614105912746.png)

GDT（global description table）全局描述符

LDT（local description table）局部错误符



如果只是进程切换，那根据TSS就可以呀，为什么还需要GDT和LDT呢？

![image-20200614112017725](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200614112017725.png)